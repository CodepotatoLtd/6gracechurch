import { Bud } from '../bud';
import { Modules } from '../registry';
import { Options } from './types';
export declare class Extension<E = any, Plugin = any> {
    _app?: () => Bud;
    app?: Bud;
    _options?: Options.FuncMap<E>;
    readonly options?: Options<E>;
    meta?: {};
    /**
     * The module name
     *
     * @public
     */
    label?: keyof Modules & string;
    /**
     * Depends on
     *
     * @public
     */
    dependsOn?: Set<`${keyof Modules & string}`>;
    /**
     * Depends on (optional)
     *
     * @public
     */
    dependsOnOptional?: Set<`${keyof Modules & string}`>;
    /**
     * Boolean or a function returning a boolean indicating if the {@link Extension} should be utilized.
     *
     * @remarks
     * If a factory is implemented, it will be passed the {@link Bud} instance as its first parameter and
     * a {@link Container} instance holding the {@link Extension.options} (if any) as the second parameter.
     *
     * @public
     */
    when?(options: Options<E>, app: Bud): Promise<boolean>;
    /**
     * Plugin constructor
     */
    plugin?: new (options: Options<E>) => Plugin;
    _init?(): Promise<void>;
    init?(options: Options<E>, app: Bud): Promise<unknown>;
    _register?(): Promise<void>;
    register?(options: Options<E>, app: Bud): Promise<unknown>;
    _boot?(): Promise<void>;
    boot?(options?: Options<E>, app?: Bud): Promise<unknown>;
    _beforeBuild?(): Promise<void>;
    beforeBuild?(options: Options<E>, app?: Bud): Promise<unknown>;
    _make?(): Promise<false | Plugin | {
        apply: any;
    }>;
    make?(options?: Options<E>, app?: Bud): Promise<Plugin>;
    /**
     * Compiler plugin `apply` method
     *
     * @public
     */
    apply?: Extension.PluginInstance['apply'];
    /**
     * @public
     */
    path?: string;
    /**
     * @public
     */
    logger?: Bud['logger']['instance'];
    /**
     * @public
     */
    constructor(_app: Bud);
    getOptions?(): Options<E>;
    setOptions?(value: Options<E> | ((value: Options<E>) => Options<E>)): this;
    getOption?<K extends keyof Options<E>>(key: K & string): Options<E>[K & string];
    setOption?<K extends keyof Options.FuncMap<E>>(key: K & string, value: Options<E>[K & string]): this;
    protected toOptionsMap?<K extends keyof Options<E>>(funcMap: Options.FuncMap<Options<E>>, [key, value]: [K & string, Options<E>[K & string]]): Options.FuncMap<Options<E>>;
    protected fromOptionsMap?<K extends keyof Options<E>>(options: Options<E>, [key, value]: [K & string, Options<E>[K & string]]): Options<E>;
    fromObject?(extensionObject: Extension): this;
    has?<K extends keyof Extension>(key: K): boolean;
    isFunction?<K extends keyof Extension>(key: K): boolean;
    /**
     * @public
     */
    resolve?(packageName: string): string;
    /**
     * @public
     */
    import?<T = any>(packageName: string): Promise<T>;
    disable?(): void;
    enable?(): void;
    /**
     * Value determining if the extension should be utilized
     *
     * @public
     */
    isEnabled?(): Promise<boolean>;
    done?(): Bud;
}
export declare namespace Extension {
    interface Constructor {
        new (...args: any[]): Extension;
    }
    type Definition = Constructor;
    /**
     * Compiler plugin interface
     *
     * @public
     */
    interface PluginInstance {
        [key: string]: any;
        /**
         * Apply method
         *
         * @public
         */
        apply?: CallableFunction;
    }
}
//# sourceMappingURL=index.d.ts.map