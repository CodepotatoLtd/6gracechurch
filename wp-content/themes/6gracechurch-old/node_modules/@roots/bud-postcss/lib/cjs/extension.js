"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const extension_1 = require("@roots/bud-framework/extension");
const decorators_1 = require("@roots/bud-framework/extension/decorators");
/**
 * PostCSS support extension for `@roots/bud`
 *
 * @public
 * @decorator `@expose`
 * @decorator `@label`
 */
let BudPostCss = class BudPostCss extends extension_1.Extension {
    constructor() {
        super(...arguments);
        this._syntax = null;
        this._sourceMap = true;
        this._plugins = new Map([]);
    }
    /**
     * postcss-loader `postcssOptions` accessor
     *
     * @public
     */
    get postcssOptions() {
        return {
            ...(this.syntax ? { syntax: this.syntax } : {}),
            ...(this.plugins.size ? { plugins: [...this.plugins.values()] } : {}),
        };
    }
    /**
     * postcss-loader's `postcssOptions.syntax`
     *
     * @public
     */
    get syntax() {
        return this._syntax;
    }
    set syntax(syntax) {
        this._syntax = syntax;
    }
    /**
     * postcss-loader's source-map option
     *
     * @public
     */
    get sourceMap() {
        return this._sourceMap;
    }
    set sourceMap(sourceMap) {
        this._sourceMap = sourceMap;
    }
    /**
     * PostCss plugins
     *
     * @public
     */
    get plugins() {
        return this._plugins;
    }
    set plugins(plugins) {
        plugins.forEach((v, k) => this._plugins.set(k, v));
    }
    /**
     * Set a plugin
     *
     * @param name - plugin handle
     * @param plugin - the plugin object or a tuple of plugin and options
     * @returns the bud.postcss instance
     *
     * @public
     * @decorator `@bind` - binds the method to the class instance
     */
    setPlugin(name, plugin) {
        const modulePath = plugin ?? [name];
        this.plugins.set(name, Array.isArray(modulePath) ? modulePath : [modulePath]);
        return this;
    }
    /**
     * Sets all plugins
     *
     * @param plugins - Map or keyed object
     * @returns the bud.postcss instance
     *
     * @public
     * @decorator `@bind` - binds the method to the class instance
     */
    setPlugins(plugins) {
        this._plugins.clear();
        const pluginMap = Array.isArray(plugins)
            ? new Map(plugins.map(plugin => [plugin, plugin]))
            : plugins instanceof Map
                ? plugins
                : new Map(Object.entries(plugins));
        pluginMap.forEach((v, k) => {
            this._plugins.set(k, Array.isArray(v) ? v : [v]);
        });
        return this;
    }
    /**
     * Remove a plugin
     *
     * @param plugin - handle of plugin to remove
     * @returns the bud.postcss instance
     *
     * @public
     * @decorator `@bind` - binds the method to the class instance
     */
    unsetPlugin(plugin) {
        this.plugins.has(plugin) && this.plugins.delete(plugin);
        return this;
    }
    /**
     * Override options on a plugin
     *
     * @param plugin - handle of plugin to modify options of
     * @param options - the options to set
     * @returns the bud.postcss instance
     *
     * @public
     * @decorator `@bind` - binds the method to the class instance
     */
    setPluginOptions(plugin, options) {
        this.plugins.set(plugin, [
            this.plugins.has(plugin) && this.plugins.get(plugin)?.length
                ? this.plugins.get(plugin).shift()
                : this.plugins.get(plugin),
            options,
        ]);
        return this;
    }
    /**
     * Extension registration
     *
     * @public
     * @decorator `@bind` - binds the method to the class instance
     */
    async register() {
        /**
         * Install postcss-loader, postcss-loader options, and
         * modify the css rule to utilize them.
         */
        this.app.build
            .setLoader('postcss', this.resolve('postcss-loader'))
            .setItem('postcss', {
            loader: 'postcss',
            options: () => {
                return {
                    postcssOptions: this.postcssOptions,
                    sourceMap: this.sourceMap,
                };
            },
        })
            .rules.css.setUse(['precss', 'css', 'postcss']);
        this.setPlugins(new Map([
            ['postcss-import', [this.resolve('postcss-import')]],
            ['postcss-nested', [this.resolve('postcss-nested')]],
            [
                'postcss-preset-env',
                [
                    this.resolve('postcss-preset-env'),
                    {
                        stage: 1,
                        features: {
                            'focus-within-pseudo-class': false,
                        },
                    },
                ],
            ],
        ]));
    }
};
__decorate([
    decorators_1.bind
], BudPostCss.prototype, "setPlugin", null);
__decorate([
    decorators_1.bind
], BudPostCss.prototype, "setPlugins", null);
__decorate([
    decorators_1.bind
], BudPostCss.prototype, "unsetPlugin", null);
__decorate([
    decorators_1.bind
], BudPostCss.prototype, "setPluginOptions", null);
__decorate([
    decorators_1.bind
], BudPostCss.prototype, "register", null);
BudPostCss = __decorate([
    (0, decorators_1.expose)('postcss'),
    (0, decorators_1.label)('@roots/bud-postcss')
], BudPostCss);
exports.default = BudPostCss;
